DEFINE
dup == LET a IN a a END ;
swap == LET a b IN b a END ;
pop == LET a IN END ;
= == - [[true] [false]] index i ;
and == * ;
or == + [[false] [true]] index i ;
not == [[true] [false]] index i ;
first == uncons pop ;
rollup == swap [swap] dip ;
step == [dup] dip swap [] = [[step2] [pop pop]] index i ;
step2 == [uncons] dip dup [swap] dip [i] first rollup [step]
	 cons cons cons cons [[] cons [first] first] dip cons i ;
dip == swap [i] first swap [] cons [first] cons cons cons i ;
* == dup 0 = [[[dup] dip mul2] [pop pop 0]] index i ;
mul2 == dup 2 < [[[dup [+] dip] dip 1 - mul2] [pop pop]] index i ;
nothing == -2147483648 ;
empty == nothing swap dup nothing = [[[pop] dip false] [pop true]] index i ;
over == swap dup [swap] dip ;
unstack2 == dup [] = [[uncons unstack2] [pop]] index i ;
stack == [] stack2 dup [unstack2] dip reverse ;
stack2 == [empty] dip swap [[cons stack2] []] index i ;
reverse == [] swap shunt ;
shunt == [cnos] step ;
cnos == swap cons ;
clear == [] clear2 ;
clear2 == [empty] dip swap [[cons clear2] [pop]] index i ;
unstack == reverse [clear] dip unstack2 ;
/ == dup 0 = [[[[0] dip] dip div2] [pop pop nothing]] index i ;
div2 == [dup 2 <] dip swap [[dup [- div3] dip div2] [pop pop]] index i ;
div3 == dup 0 < [[[1 +] dip] []] index i ;
true == false 1 + ;
false == 1 0 < ;
.
111 222 + .
1 2 + 3 4 + * .
2 2 + 2 2 * = .
DEFINE > == swap < .
6 6 * 5 7 * > .
true false or true and not .
#DEFINE	reverse	== [] swap shunt ;
#	shunt	== [cnos] step ;
#	cnos	== swap cons .
[1 2 3 4 5] reverse .
DEFINE	concat	== [reverse] c shunt ;
	c	== [swap] dip i .
[peter paul] [mary jane] concat .
DEFINE	last	== dup rest null
		   [first] [rest last] branch ;
#	null	== car nothing sametype ;
	null	== 0 = ;
	car	== uncons pop ;
#	first	== uncons pop ;
	rest	== uncons swap pop ;
	branch	== swap pair index i ;
	pair	== [] cons cons .
[11 false 'X 44] last .
DEFINE	member	== swap contains ;
	contains == false swap [= or] cons fold ;
	fold	== [swap] dip step .
3 [1 5 3 4 2] member .
3 [1 5 6 4 2] member .
DEFINE	sum	== 0 [+] fold ;
	space	== '\32 ;
	product	== 1 [*] fold .
[1 2 3 4] dup sum put space put product .
111 [222 333] cons .
DEFINE	putsp	== put space put ;
	nl	== '\10 put .
[11 22 33 44 55] uncons uncons putsp putsp putsp nl .
['a 'b] ['d 'e 'f] concat dup .
uncons uncons 'c swap cons cons cons dup .
DEFINE	length	== 0 [pop 1 +] fold .
dup length .
reverse length .
get get + .
123 456
pop pop 111 222 [+ put] i nl .
111 [put +] reverse 222 swap i nl .
3 7 100 [*] dip + .
[1 2 3] [dup * putsp] step nl .
2 [dup *] i .
DEFINE	twice	== dup b ;
	b	== [i] dip i .
2 [dup *] twice .
DEFINE	thrice	== dup [twice] dip i .
2 [dup *] thrice .
DEFINE	square	== dup * ;
	times	== dup 0 =
		   [pop pop]
		   [[dup [i] dip] dip pred times] branch ;
	pred	== 1 - .
2 [square] 0 times .
2 [square] 1 times .
2 [square] 2 times .
2 [square] 3 times .
2 [square] 4 times .
#2 [square] 5 times .
[7] 10 times stack .
DEFINE	map	== maprev reverse ;
	maprev	== [] rollup shuntmap ;
#	rollup	== swap [swap] dip ;
	shuntmap == [[cnos] b] cons step .
[1 2 3] [dup *] map .
[1 2 3] 0 [dup * +] fold .
DEFINE	unit	== [] cons ;
	construct2 == [[nullary] cons dip swap] map ;
	nullary	== stack swap dip rest cons unstack .
11 12 [[+] [*] [pop unit] [dup pair]] construct2 .
DEFINE	unpair	== uncons uncons pop .
[[pair [square] map unpair +] [pop] []] construct2 .
[] unstack 11111 .
64 .
64 .
255 .
'\65 .
'\97 .
'g .
[Smith Jones Robinson] last .
DEFINE	definition == first body .
[last] definition .
[Smith Jones Robinson] [last] definition i .
DEFINE	cdr	== uncons swap pop ;
	x	== dup i .
[Smith Jones Robinson]
[swap dup rest null [car swap pop] [cdr swap x] branch] x .
DEFINE	y	== fix i ;
	fix	== [duco] first swap cons duco ;
	duco	== dup cons .
[Smith Jones Robinson]
[swap dup rest null [car swap pop] [cdr swap i] branch] y .
DEFINE	factorial_rec == dup 1 <=
			 [pop 1] [dup pred factorial_rec *]
			 branch ;
	<=	== succ < ;
	succ	== 1 + .
6 factorial_rec .
DEFINE	rolldown == [swap] dip swap .
6 [swap dup 1 <= [pop pop 1] [dup pred rolldown x *] branch] x .
6 [swap dup 1 <= [pop pop 1] [dup pred rolldown i *] branch] y .
DEFINE	quicksort == dup small []
		     [partition quicksort [quicksort] dip concat]
		     branch ;
#	small == uncons null swap pop ;
	small == dup null [ [ uncons null ] [ true ] ] index i swap pop ;
	partition == [[][]] dip dup [first > [cnos] [swap [cnos]
		     dip] branch] cons [dup] first cnos step ;
	putln	  == put nl .
[1 9 2 8 3 7 4 6 5] quicksort putln .
[5 6 4 7 3 8 2 9 1] quicksort putln .
[1 2 3 4 5 6 7 8 9] quicksort putln .
[9 8 7 6 5 4 3 2 1] quicksort putln .
[quicksort] definition putln .
DEFINE	quicksort1 == dup small []
		      [partition1 quicksort1 [quicksort1] dip concat]
		      branch ;
	partition1 == [[][]] dip dup first [first > [cnos] [swap [cnos]
		      dip] branch] cons [first] first cnos [dup] first
		      cnos step .
[[1 Smith] [3 Jones] [2 Robinson] [4 Brown]] quicksort1 putln .
[] [NURKS Peter 1989 year 3 major Computer Science] cnos
   [ABELSON Mary 1990 year 2 major Logic] cnos
   [ZEEMAN Fred 1988 year 2 major Accounting] cnos
   [MORRIS Janna 1992 year 1 major undecided] cnos
quicksort1 dup [putln] step pop .
